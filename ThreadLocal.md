# ThreadLocal


### 对象在内存中的状态

- 可达状态
- 可恢复状态
- 不可达状态

1.可达状态

当一个对象被创建后，有一个或多个引用他（即将对象的引用看成一个有向图的顶点，可通过别的顶点到到对象）即为可达状态。

2.可恢复状态

当对象失去引用（即对象的在有向图中不能通过别的顶点和边到达对象).先进入可恢复状态，这次准备GC，如果恢复获取引用，又进入可达状态。

3.不可达状态

对象失去引用，可恢复状态也没有再次进入可达状态，此时就进入不可达状态，GC后对象被回收。



### 四种引用
- 强引用
- 软引用
- 弱引用
- 虚引用

1.强引用

通过new所创建的对象，所创建的对象在堆中，栈引用堆中的对象，如果栈中始终引用堆中对象，则不会对其进行Gc.

2.软引用

和强引用类似，但是当发生内存不足的时候，被引用也会对其进行GC。

3.弱引用

当发生gc是，弱引用直接背gc掉

4.虚引用 

太弱，一般不考虑。


### ThreadLocal描述

- 1.存储数据

维护的是一个key，value的形式，key是当前线程的副本，key是调用方法set时往里设的值，当存储多个值的时候并没有像hashmap那样使用链式存储或者红黑树旋转数据结构而是使用的线性探测法。

- 2.key的弱引用

在每一个Thread里为维护了一个一个ThreadLocalMap，并不是直接继承的map，里面维护了一个entry继承的弱引用，key会在构建是调用其父类的构造，使key成为一个弱引用,value保存在entry中。

- 3.垃圾回收和内存泄露

当发生gc时，由于key是弱引用，直接将弱引用回收，置为null，在线程未结束的时候entry中的value是不会被回收的，当线程完成是，随着线程被回收，value也被回收。如果使用线程池，线程结束时如果没有进行处理的话，value永远不会被回收，即造成内存泄露。

